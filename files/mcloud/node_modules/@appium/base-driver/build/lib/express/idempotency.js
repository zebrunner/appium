"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleIdempotency = void 0;
const logger_1 = __importDefault(require("./logger"));
const lru_cache_1 = __importDefault(require("lru-cache"));
const support_1 = require("@appium/support");
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const events_1 = require("events");
const CACHE_SIZE = 1024;
const IDEMPOTENT_RESPONSES = new lru_cache_1.default({
    max: CACHE_SIZE,
    updateAgeOnGet: true,
    dispose(key, { response }) {
        if (response) {
            logger_1.default.info(`[MCLOUD] IDEMPOTENT_RESPONSES. Deleting files by path: ${response}`);
            support_1.fs.rimrafSync(response);
        }
    },
});
const MONITORED_METHODS = ['POST', 'PATCH'];
const IDEMPOTENCY_KEY_HEADER = 'x-idempotency-key';
process.on('exit', () => {
    const resPaths = [...IDEMPOTENT_RESPONSES.values()].map(({ response }) => response).filter(Boolean);
    for (const resPath of resPaths) {
        try {
            // Asynchronous calls are not supported in onExit handler
            logger_1.default.info(`[MCLOUD] process.on('exit'). Deleting files by path: ${resPath}`);
            support_1.fs.rimrafSync(resPath);
        }
        catch (ign) { }
    }
});
function cacheResponse(key, req, res) {
    const responseStateListener = new events_1.EventEmitter();
    IDEMPOTENT_RESPONSES.set(key, {
        method: req.method,
        path: req.path,
        response: null,
        responseStateListener,
    });
    const tmpFile = path_1.default.resolve(os_1.default.tmpdir(), `${support_1.util.uuidV4()}.response`);
    const responseListener = support_1.fs.createWriteStream(tmpFile, {
        emitClose: true,
    });
    const originalSocketWriter = res.socket.write.bind(res.socket);
    const patchedWriter = (chunk, encoding, next) => {
        if (responseListener.writable) {
            responseListener.write(chunk);
        }
        return originalSocketWriter(chunk, encoding, next);
    };
    res.socket.write = patchedWriter;
    let writeError = null;
    let isResponseFullySent = false;
    responseListener.once('error', (e) => {
        writeError = e;
    });
    res.once('finish', () => {
        isResponseFullySent = true;
        responseListener.end();
    });
    res.once('close', () => {
        if (!isResponseFullySent) {
            responseListener.end();
        }
    });
    responseListener.once('close', () => {
        if (res.socket?.write === patchedWriter) {
            res.socket.write = originalSocketWriter;
        }
        if (!IDEMPOTENT_RESPONSES.has(key)) {
            logger_1.default.info(`Could not cache the response identified by '${key}'. ` +
                `Cache consistency has been damaged`);
            return responseStateListener.emit('ready', null);
        }
        if (writeError) {
            logger_1.default.info(`Could not cache the response identified by '${key}': ${writeError.message}`);
            IDEMPOTENT_RESPONSES.delete(key);
            return responseStateListener.emit('ready', null);
        }
        if (!isResponseFullySent) {
            logger_1.default.info(`Could not cache the response identified by '${key}', ` +
                `because it has not been completed`);
            logger_1.default.info('Does the client terminate connections too early?');
            IDEMPOTENT_RESPONSES.delete(key);
            return responseStateListener.emit('ready', null);
        }
        IDEMPOTENT_RESPONSES.get(key).response = tmpFile;
        responseStateListener.emit('ready', tmpFile);
    });
}
async function handleIdempotency(req, res, next) {
    const key = req.headers[IDEMPOTENCY_KEY_HEADER];
    if (!key) {
        return next();
    }
    if (!MONITORED_METHODS.includes(req.method)) {
        // GET, DELETE, etc. requests are idempotent by default
        // there is no need to cache them
        return next();
    }
    logger_1.default.debug(`Request idempotency key: ${key}`);
    if (!IDEMPOTENT_RESPONSES.has(key)) {
        cacheResponse(key, req, res);
        return next();
    }
    const { method: storedMethod, path: storedPath, response, responseStateListener, } = IDEMPOTENT_RESPONSES.get(key);
    if (req.method !== storedMethod || req.path !== storedPath) {
        logger_1.default.warn(`Got two different requests with the same idempotency key '${key}'`);
        logger_1.default.warn('Is the client generating idempotency keys properly?');
        return next();
    }
    const rerouteCachedResponse = async (cachedResPath) => {
        if (!(await support_1.fs.exists(cachedResPath))) {
            IDEMPOTENT_RESPONSES.delete(key);
            logger_1.default.warn(`Could not read the cached response identified by key '${key}'`);
            logger_1.default.warn('The temporary storage is not accessible anymore');
            return next();
        }
        support_1.fs.createReadStream(cachedResPath).pipe(res.socket);
    };
    if (response) {
        logger_1.default.info(`The same request with the idempotency key '${key}' has been already processed`);
        logger_1.default.info(`Rerouting its response to the current request`);
        await rerouteCachedResponse(response);
    }
    else {
        logger_1.default.info(`The same request with the idempotency key '${key}' is being processed`);
        logger_1.default.info(`Waiting for the response to be rerouted to the current request`);
        responseStateListener.once('ready', async (cachedResponsePath) => {
            if (!cachedResponsePath) {
                return next();
            }
            await rerouteCachedResponse(cachedResponsePath);
        });
    }
}
exports.handleIdempotency = handleIdempotency;
//# sourceMappingURL=idempotency.js.map