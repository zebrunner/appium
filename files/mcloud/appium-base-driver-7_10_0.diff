diff --git a/lib/basedriver/commands/session.js b/lib/basedriver/commands/session.js
index f1264e8..7be543a 100644
--- a/lib/basedriver/commands/session.js
+++ b/lib/basedriver/commands/session.js
@@ -4,10 +4,20 @@ import log from '../logger';
 import { errors } from '../../protocol';
 import { util } from 'appium-support';
 import { processCapabilities } from '../capabilities';
+import { executeShell } from '../mcloud-utils';
 
 let commands = {};
 
 commands.createSession = async function createSession (jsonwpDesiredCapabilities, jsonwpRequiredCaps, w3cCapabilities) {
+  log.debug(`[MCLOUD] resetting logs`);
+  const reset_log_command = `/opt/reset-logs.sh`;
+  executeShell(reset_log_command, '[MCLOUD] reset appium logs');
+
+  // TODO: test negative cases. Seems like we handled it correctly on session finish and during appium container termination
+  //  _logger.default.debug(`[MCLOUD] stopping capturing artifacts before session startup`);
+  //  const stop_rec_command = `/opt/stop-capture-artifacts.sh`;
+  //  (0, _mcloudUtils.executeShell)(stop_rec_command, '[MCLOUD] stop capturing artifacts before session startup');
+
   if (this.sessionId !== null) {
     throw new errors.SessionNotCreatedError('Cannot create a new session ' +
                                             'while one is in progress');
@@ -80,6 +90,13 @@ commands.createSession = async function createSession (jsonwpDesiredCapabilities
 
   log.info(`Session created with session id: ${this.sessionId}`);
 
+  log.debug(`[MCLOUD] Starting artifacts capturing for init steps`);
+  const start_rec_command = `/opt/start-capture-artifacts.sh ${this.sessionId} > /tmp/video.log 2>&1`;
+  executeShell(start_rec_command, '[MCLOUD] start artifacts capturing for init steps'); // 1 error code expected as process should be killed
+  
+  // save current sessionId globally to handle negative use-case instead of desired fallbackSessionId
+  process.env.sessionId = this.sessionId
+
   return [this.sessionId, caps];
 };
 
@@ -111,6 +128,19 @@ commands.deleteSession = async function deleteSession (/* sessionId */) {
       this.commandsQueueGuard.queues[key] = [];
     }
   }
+
+  // stop recording
+  log.debug(`[MCLOUD] stopping capturing artifacts for session ${this.sessionId}`);
+  const stop_rec_command = `/opt/stop-capture-artifacts.sh ${this.sessionId}`;
+  executeShell(stop_rec_command, '[MCLOUD] stop capturing artifacts');
+
+  await new Promise(resolve => setTimeout(resolve, 300));
+
+  // upload video
+  log.debug(`[MCLOUD] uploading captured artifacts`);
+  const upload_video_command = `/opt/upload-artifacts.sh ${this.sessionId} >> /tmp/video.log`;
+  executeShell(upload_video_command, '[MCLOUD] upload captured artifacts');
+
   this.sessionId = null;
 };
 
diff --git a/lib/basedriver/driver.js b/lib/basedriver/driver.js
index 867b861..651eea6 100644
--- a/lib/basedriver/driver.js
+++ b/lib/basedriver/driver.js
@@ -18,6 +18,8 @@ import {
 } from './image-element';
 import AsyncLock from 'async-lock';
 import { EventEmitter } from 'events';
+import { executeShell, executeShellWPromise, parseWDAUrl, getWDAStatus } from './mcloud-utils';
+import { logger } from 'appium-support';
 
 
 B.config({
@@ -177,6 +179,43 @@ class BaseDriver extends Protocol {
     return {};
   }
 
+  async getStatusWDA () {
+    const wdaURL = await parseWDAUrl();
+    if (!wdaURL) {
+      throw new Error("Environment variable WDA_ENV is undefined");
+    }
+    const status = await getWDAStatus(wdaURL);
+    if (!status) {
+      throw new Error("Error for sending of WDA status http call. See appium logs for details");
+    }
+    return {"status": "success", "details": status};
+  }
+
+  async getStatusADB() {
+    const deviceUDID = process.env.DEVICE_UDID;
+    if (deviceUDID) {
+      const adbDevicesCmd = 'adb devices | grep $DEVICE_UDID | grep "device"';
+      try {
+        await executeShellWPromise(adbDevicesCmd);
+        return {"status": "success", "details": `Connected device with UDID ${deviceUDID} is ready for execution`};
+      } catch (error) {
+        throw new Error(`Connected device with UDID ${deviceUDID} is NOT ready for execution. Device was not returned by adb`);
+      }
+    } else {
+      const deviceName = process.env.ANDROID_DEVICES;
+      if(!deviceName) {
+        throw new Error(`Neither DEVICE_UDID nor ANDROID_DEVICES environment variables were found.`);
+      }
+      const adbDevicesCmd = 'adb devices | grep $ANDROID_DEVICES | grep "device"';
+      try {
+        await executeShellWPromise(adbDevicesCmd);
+        return {"status": "success", "details": `Connected device with name ${deviceName} is ready for execution`};
+      } catch (error) {
+        throw new Error(`Connected device with name ${deviceUDID} is NOT ready for execution. Device was not returned by adb`);
+      }
+    }
+  }
+
   // we only want subclasses to ever extend the contraints
   set desiredCapConstraints (constraints) {
     this._constraints = Object.assign(this._constraints, constraints);
@@ -339,6 +378,10 @@ class BaseDriver extends Protocol {
         })
       ]).finally(() => {
         if (unexpectedShutdownListener) {
+          if (cmd === 'createSession') {
+            log.info('[MCLOUD] error happened during new session creating');
+          }
+
           // This is needed to prevent memory leaks
           this.eventEmitter.removeListener(ON_UNEXPECTED_SHUTDOWN_EVENT, unexpectedShutdownListener);
           unexpectedShutdownListener = null;
@@ -364,6 +407,12 @@ class BaseDriver extends Protocol {
     this._eventHistory.commands.push({cmd, startTime, endTime});
     if (cmd === 'createSession') {
       this.logEvent(EVENT_SESSION_START);
+
+      if(res != undefined && res.value != undefined) {
+        log.info(`[MCLOUD] starting artifacts capturing for session ${res.value[0]}`);
+        const start_rec_command = `/opt/start-capture-artifacts.sh ${res.value[0]} >> /tmp/video.log 2>&1`;
+        executeShell(start_rec_command, '[MCLOUD] start capturing artifacts'); // 1 error code expected as process should be killed
+      }
     } else if (cmd === 'deleteSession') {
       this.logEvent(EVENT_SESSION_QUIT_DONE);
     }
diff --git a/lib/basedriver/helpers.js b/lib/basedriver/helpers.js
index fcbf49d..df1658c 100644
--- a/lib/basedriver/helpers.js
+++ b/lib/basedriver/helpers.js
@@ -6,6 +6,7 @@ import { tempDir, fs, util, zip, net, timing } from 'appium-support';
 import LRU from 'lru-cache';
 import AsyncLock from 'async-lock';
 import axios from 'axios';
+import { getLocalAppsFolder, getSharedFolderForAppUrl, getLocalFileForAppUrl, getFileContentLength } from './mcloud-utils';
 
 const IPA_EXT = '.ipa';
 const ZIP_EXTS = ['.zip', IPA_EXT];
@@ -68,7 +69,7 @@ async function retrieveHeaders (link) {
 
 function getCachedApplicationPath (link, currentAppProps = {}) {
   const refresh = () => {
-    logger.debug(`A fresh copy of the application is going to be downloaded from ${link}`);
+    logger.debug(`[MCLOUD] A fresh copy of the application is going to be downloaded from ${link}`);
     return null;
   };
 
@@ -133,6 +134,7 @@ async function configureApp (app, supportedAppExtensions) {
   let newApp = app;
   let shouldUnzipApp = false;
   let archiveHash = null;
+  let localAppsFolder;
   const remoteAppProps = {
     lastModified: null,
     immutable: false,
@@ -160,6 +162,93 @@ async function configureApp (app, supportedAppExtensions) {
         }
         logger.debug(`Cache-Control: ${headers['cache-control']}`);
       }
+
+      // ***** Custom logic for verification of local static path for APPs *****
+      let downloadIsNeaded = true;
+      localAppsFolder = await getLocalAppsFolder();
+      let localFile;
+      let lockFile;
+      const waitingTime = 1000;
+      const maxAttemptsCount = process.env.APPIUM_APP_WAITING_TIMEOUT;
+      
+      if(localAppsFolder != undefined) {
+        localFile = await getLocalFileForAppUrl(newApp);
+        lockFile = localFile + '.lock';
+
+        if(await fs.exists(localFile)) {
+          logger.info(`[MCLOUD] Local version of app was found. Will check actuality of the file`);
+          // Checking of local application actuality
+          const remoteFileLength = await getFileContentLength(app);
+          // At this point local file might be deleted by parallel session which updates outdated app
+          let attemptsCount = 0;
+          while(!await fs.exists(localFile) && (attemptsCount++ < maxAttemptsCount)) {
+            await new Promise((resolve) => {
+              logger.info(`[MCLOUD] Attempt #${attemptsCount} for local app file to appear again`);
+              setTimeout(resolve, waitingTime);
+            });
+          }
+          if(!await fs.exists(localFile)) {
+            throw Error(`[MCLOUD] Local application file has not appeared after updating by parallel Appium session`);
+          }
+          const stats = await fs.stat(localFile);
+          const localFileLength = stats.size;
+          logger.info(`[MCLOUD] Remote file size is ${remoteFileLength} and local file size is ${localFileLength}`);
+          if(remoteFileLength == undefined) {
+            logger.warn(`[MCLOUD] We could not retrieve remote app size. But since env variable CHECK_APP_SIZE_OPTIONALLY=true old app file will be used.`);
+            newApp = localFile;
+            shouldUnzipApp = ZIP_EXTS.includes(path.extname(newApp));
+            downloadIsNeaded = false;
+          } else if(remoteFileLength != localFileLength) {
+            logger.info(`[MCLOUD] Sizes differ. Hence that's needed to download fresh version of the app`);
+            if (await fs.exists(localFile)) {
+              await fs.unlink(localFile);
+            } else {
+              logger.warn(`[MCLOUD] Old local application file ${localFile} was not found. Probably it was removed by another thread which was downloading app in parallel`);
+            }
+            downloadIsNeaded = true;
+          } else {
+            logger.info(`[MCLOUD] Sizes are the same. Hence will use already stored application for the session`);
+            newApp = localFile;
+            shouldUnzipApp = ZIP_EXTS.includes(path.extname(newApp));
+            downloadIsNeaded = false;
+          }
+        } else if (await fs.exists(lockFile)) {
+          logger.info(`[MCLOUD] Local version of app not found but .lock file exists. Waiting for .lock to disappear`);
+          // Wait for some time till App is downloaded by some parallel Appium instance
+          let attemptsCount = 0;
+          while(await fs.exists(lockFile) && (attemptsCount++ < maxAttemptsCount)) {
+            await new Promise((resolve) => {
+              logger.info(`[MCLOUD] Attempt #${attemptsCount} for .lock file checking`);
+              setTimeout(resolve, waitingTime);
+            });
+          }
+          if(await fs.exists(lockFile)) {
+            throw Error(`[MCLOUD] .lock file for downloading application has not disappeared after ${waitingTime * maxAttemptsCount}ms`);
+          }
+          if(!await fs.exists(localFile)) {
+            throw Error(`[MCLOUD] Local application file has not appeared after .lock file removal`);
+          }
+          logger.info(`[MCLOUD] Local version of app was found after .lock file removal. Will use it for new session`);
+          newApp = localFile;
+          shouldUnzipApp = ZIP_EXTS.includes(path.extname(newApp));
+          downloadIsNeaded = false;
+        } else {
+          logger.info(`[MCLOUD] Neither local version of app nor .lock file was found. Will download app from remote URL.`);
+          downloadIsNeaded = true;
+        }
+      } else {
+        logger.info(`[MCLOUD] Local apps folder is not defined via environment properties, hence skipping this logic. Use variable APPIUM_APPS_DIR for path setting`);
+      }
+      if(downloadIsNeaded) {
+      
+        if(localAppsFolder != undefined) {
+          logger.info(`[MCLOUD] Local version of app was not found. Hence using default Appium logic for downloading`);
+          const sharedFolderPath = await getSharedFolderForAppUrl(app);
+          logger.info(`[MCLOUD] Folder for local shared apps: ${sharedFolderPath}`);
+          await fs.close(await fs.open(lockFile, 'w'));
+        }
+
+        try {
       const cachedPath = getCachedApplicationPath(app, remoteAppProps);
       if (cachedPath) {
         if (await fs.exists(cachedPath)) {
@@ -220,6 +309,24 @@ async function configureApp (app, supportedAppExtensions) {
         suffix: '',
       });
       newApp = await downloadApp(newApp, targetPath);
+
+      // ***** Custom logic for copying of downloaded app to static location *****
+      if(localAppsFolder != undefined) {
+        logger.info(`[MCLOUD] New app path: ${newApp}`);
+        await fs.copyFile(newApp, localFile);
+      }
+      }
+      finally {
+        if(localAppsFolder != undefined) {
+          logger.info(`[MCLOUD] Going to remove lock file ${lockFile}`)
+          if (await fs.exists(lockFile)) {
+            await fs.unlink(lockFile);
+          } else {
+            logger.warn(`[MCLOUD] Lock file ${lockFile} was not found. Probably it was removed by another thread which was downloading app in parallel`);
+          }
+        }
+      }
+      }
     } else if (await fs.exists(newApp)) {
       // Use the local app
       logger.info(`Using local app '${newApp}'`);
@@ -240,7 +347,7 @@ async function configureApp (app, supportedAppExtensions) {
       if (APPLICATIONS_CACHE.has(app) && archiveHash === APPLICATIONS_CACHE.get(app).hash) {
         const {fullPath} = APPLICATIONS_CACHE.get(app);
         if (await fs.exists(fullPath)) {
-          if (archivePath !== app) {
+          if (archivePath !== app && localAppsFolder === undefined) {
             await fs.rimraf(archivePath);
           }
           logger.info(`Will reuse previously cached application at '${fullPath}'`);
@@ -253,7 +360,7 @@ async function configureApp (app, supportedAppExtensions) {
       try {
         newApp = await unzipApp(archivePath, tmpRoot, supportedAppExtensions);
       } finally {
-        if (newApp !== archivePath && archivePath !== app) {
+        if (newApp !== archivePath && archivePath !== app && localAppsFolder === undefined) {
           await fs.rimraf(archivePath);
         }
       }
diff --git a/lib/basedriver/mcloud-utils.js b/lib/basedriver/mcloud-utils.js
new file mode 100644
index 0000000..a828186
--- /dev/null
+++ b/lib/basedriver/mcloud-utils.js
@@ -0,0 +1,139 @@
+import fs from 'appium-support/build/lib/fs';
+import nodePath from 'path';
+import axios from 'axios';
+import path from 'path';
+import logger from './logger';
+import util from 'util';
+import { exec } from 'child_process';
+
+async function getLocalAppsFolder() {
+    return process.env.APPIUM_APPS_DIR;
+}
+
+async function getSharedFolderForAppUrl(url) {
+    const sub = await getLocalFileForAppUrl(url);
+
+    const lastSlashInd = sub.lastIndexOf(path.sep);
+    var targetPath;
+    if(lastSlashInd != -1) {
+        targetPath = sub.substring(0, lastSlashInd);
+    } else {
+        targetPath = '';
+    }
+
+    logger.info(`[MCLOUD] Target path [getSharedFolderForAppUrl]: ${targetPath}`)
+    const folderExists = await fs.exists(targetPath);
+    if(!folderExists)
+        await fs.mkdir(targetPath, {recursive : true});
+  
+    return targetPath;
+}
+
+async function getLocalFileForAppUrl(url) {
+    var sub = url.substring(url.indexOf('//') + 2)
+    sub = sub.substring(sub.indexOf('/'));
+    if(sub.includes('?')) {
+        sub = sub.substring(0, sub.indexOf('?'));
+    }
+    sub = sub.replace(/\//g, path.sep);
+
+    const targetPath = nodePath.join(await getLocalAppsFolder(), sub);
+    logger.info(`[MCLOUD] Target path [getLocalFileForAppUrl]: ${targetPath}`)
+    return targetPath;
+}
+
+async function getFileContentLength(remoteUrl) {
+    const timeout = 10000;
+    const retries = 5;
+    const pollingInterval = 3000;
+    const check_app_size_optionally = process.env.CHECK_APP_SIZE_OPTIONALLY;
+    logger.info(`[MCLOUD] env CHECK_APP_SIZE_OPTIONALLY=${check_app_size_optionally}`);
+
+    const requestOpts = {
+        url: remoteUrl,
+        responseType: 'stream',
+        timeout,
+    };
+
+    // getting content-length with retry
+    var lastError;
+    const getLengthRequest = async () => {
+        for (var i=0; i<retries; i++) {
+            try {
+                logger.debug(`[MCLOUD] Making GET http call for retrieving of remote app size`);
+                const {
+                    headers: responseHeaders,
+                } = await axios(requestOpts);
+                const responseLength = parseInt(responseHeaders['content-length'], 10);
+                logger.debug(`[MCLOUD] CONTENT-LENGTH for the file: ${responseLength}`);
+                return responseLength;
+            } catch (error) {
+                lastError = error;
+                console.log(`[MCLOUD] Cannot fetch info about app size. Will retry attempt in ${pollingInterval}ms`);
+                await new Promise(resolve => setTimeout(resolve, pollingInterval));
+            }
+        }
+    }
+    const length = await getLengthRequest();
+    if(length) {
+        return length;
+    } else if (check_app_size_optionally !== undefined && check_app_size_optionally === 'true') {
+        logger.debug(`[MCLOUD] Returning app size as undefined`);
+        return undefined;
+    } else {
+        throw new Error(`[MCLOUD] Cannot get file content-length from ${remoteUrl} after ${retries} retry(s): ${lastError}`);
+    }
+}
+
+function executeShell(shellCommand, description) {
+    exec(shellCommand, (error, stdout, stderr) => {
+        if (error) {
+            logger.info(`[MCLOUD] ${description} error: ${error.message}`);
+            return;
+        }
+        if (stderr) {
+            logger.info(`[MCLOUD] ${description} stderr: ${stderr}`);
+            return;
+        }
+        logger.info(`[MCLOUD] ${description} command was successfully executed`);
+      });
+}
+
+async function executeShellWPromise(shellCommand) {
+    const execPromisify = util.promisify(exec);
+    return await execPromisify(shellCommand);
+}
+
+async function parseWDAUrl() {
+    const wdaEnv = process.env.WDA_ENV;
+    if (wdaEnv) {
+        const wdaEnvContent = await fs.readFile(wdaEnv);
+        const regexHost = new RegExp('export WDA_HOST=(.*)');
+        var host;
+        var r = String(wdaEnvContent).match(regexHost);
+        if (r)
+            host = r[1]; 
+        const regexPort = new RegExp('export WDA_PORT=(.*)');
+        var port;
+        var r = String(wdaEnvContent).match(regexPort);
+        if (r)
+            port = r[1]; 
+        return `http://${host}:${port}/status`;
+    }
+    return undefined;
+}
+
+async function getWDAStatus(wdaURL) {
+    try {
+        return (await axios({
+          url: wdaURL,
+          method: 'GET',
+          timeout: 5000,
+        })).data;
+      } catch (e) {
+        logger.info(`Cannot send GET request to '${wdaURL}'. Original error: ${e.message}`);
+        return undefined;
+      }
+}
+
+module.exports = { getLocalAppsFolder, getSharedFolderForAppUrl, getLocalFileForAppUrl, getFileContentLength, executeShell, executeShellWPromise, parseWDAUrl, getWDAStatus }
\ No newline at end of file
diff --git a/lib/protocol/protocol.js b/lib/protocol/protocol.js
index fd457dc..361731b 100644
--- a/lib/protocol/protocol.js
+++ b/lib/protocol/protocol.js
@@ -357,6 +357,9 @@ function buildHandler (app, method, path, spec, driver, isSessCmd) {
         SESSIONS_CACHE.resetLogger(req.params.sessionId);
       }
     } catch (err) {
+      // PATCH #2 <appium>/node_modules/appium/node_modules/appium-base-driver/build/lib/protocol/protocol.js to return to carina "DEBUG info" about problematic step
+      err.message = `${err.message}[[[--udid ${process.env.DEVICE_UDID} --name ${process.env.DEVICE_NAME} --sessionId ${process.env.sessionId}]]]`;
+
       // if anything goes wrong, figure out what our response should be
       // based on the type of error that we encountered
       let actualErr = err;
diff --git a/lib/protocol/routes.js b/lib/protocol/routes.js
index 59cc5c6..086b693 100644
--- a/lib/protocol/routes.js
+++ b/lib/protocol/routes.js
@@ -18,6 +18,12 @@ const METHOD_MAP = {
   '/status': {
     GET: {command: 'getStatus'}
   },
+  '/status-wda': {
+    GET: {command: 'getStatusWDA'}
+  },
+  '/status-adb': {
+    GET: {command: 'getStatusADB'}
+  },
   '/session': {
     POST: {command: 'createSession', payloadParams: {
       validate: (jsonObj) => (!jsonObj.capabilities && !jsonObj.desiredCapabilities) && 'we require one of "desiredCapabilities" or "capabilities" object',
@@ -843,6 +849,6 @@ function routeToCommandName (endpoint, method, basePath = DEFAULT_BASE_PATH) {
 }
 
 // driver commands that do not require a session to already exist
-const NO_SESSION_ID_COMMANDS = ['createSession', 'getStatus', 'getSessions'];
+const NO_SESSION_ID_COMMANDS = ['createSession', 'getStatus', 'getStatusWDA', 'getStatusADB', 'getSessions'];
 
 export { METHOD_MAP, ALL_COMMANDS, NO_SESSION_ID_COMMANDS, routeToCommandName };
